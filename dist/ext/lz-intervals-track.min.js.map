{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/external \"d3\"","webpack://[name]/./esm/ext/lz-intervals-track.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","d3","XCS","for","YCS","XCE","YCE","install","LocusZoom","BaseApiAdapter","Adapters","_Button","Widgets","_BaseWidget","default_layout","start_field","end_field","track_label_field","track_split_field","track_split_order","track_split_legend_to_y_axis","split_tracks","track_height","track_vertical_spacing","bounding_box_padding","always_hide_legend","color","fill_opacity","tooltip_positioning","BaseLayer","DataLayers","intervals_tooltip_layout","namespace","closable","show","or","hide","and","html","intervals_layer_layout","id","type","fields","id_field","field","scale_function","parameters","categories","values","null_value","legend","behaviors","onmouseover","action","status","onmouseout","onclick","exclusive","onshiftclick","tooltip","intervals_panel_layout","min_height","height","margin","top","right","bottom","left","toolbar","Layouts","unnamespaced","widgets","push","data_layer_id","position","axes","interaction","drag_background_to_pan","scroll_to_zoom","x_linked","hidden","orientation","origin","x","y","pad_from_bottom","data_layers","intervals_plot_layout","state","width","responsive_resize","min_region_scale","max_region_scale","panels","merge","add","chain","query","header","bedtracksource","this","params","source","chr","end","start","url","layout","super","arguments","_previous_categories","_categories","initialize","_statusnodes_group","svg","group","append","attr","_datanodes_group","data","result","forEach","item","item_key","allow_overlap","grouped_data","index","length","row_to_test","last_item","x_scale","parent","_arrangeTrackSplit","_arrangeTracksLinear","keys","reverse","row_index","getTrackHeight","track","reduce","acc","val","concat","element","getBaseId","replace","self","base_layout","_base_layout","render_layout","base_color_scale","find","color_scale","Error","has_colors","has_legend","rgb_option","rgb_field","known_categories","_generateCategoriesFromData","colors","_makeColorScheme","map","pair","shape","label","_applyLayoutOptions","assigned_data","_assignTracks","every","updateSplitTrackAxis","track_data","_applyFilters","selectAll","remove","status_nodes","enter","getElementStatusNodeId","cliparea","exit","data_nodes","getElementId","resolveScalableParameter","applyBehaviors","render","x_min","x_max","y_min","y_max","legend_axis","tracks","track_spacing","target_height","scaleHeightToData","ticks","range","findIndex","Math","abs","text","y_axis","axis","floor","ceiling","parent_plot","positionPanels","category_info","n_categories","unique_ids","ScaleFunctions","parent_panel","data_layer","button","setHtml","setColor","setTitle","setOnclick","toggleSplitTracks","scale_timeout","clearTimeout","setTimeout","update","use"],"mappings":"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","file":"ext/lz-intervals-track.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","module.exports = d3;","/**\n * Interval annotation track (for chromatin state, etc). Useful for BED file data with non-overlapping intervals.\n *  This is not part of the core LocusZoom library, but can be included as a standalone file.\n *\n * ### Features provided\n * * {@link module:LocusZoom_Adapters~IntervalLZ}\n * * {@link module:LocusZoom_Widgets~toggle_split_tracks}\n * * {@link module:LocusZoom_ScaleFunctions~to_rgb}\n * * {@link module:LocusZoom_DataLayers~intervals}\n * * {@link module:LocusZoom_Layouts~standard_intervals}\n * * {@link module:LocusZoom_Layouts~intervals_layer}\n * * {@link module:LocusZoom_Layouts~intervals}\n * * {@link module:LocusZoom_Layouts~interval_association}\n *\n * ### Loading and usage\n * The page must incorporate and load all libraries before this file can be used, including:\n * - LocusZoom\n *\n * To use in an environment without special JS build tooling, simply load the extension file as JS from a CDN (after any dependencies):\n * ```\n * <script src=\"https://cdn.jsdelivr.net/npm/locuszoom@INSERT_VERSION_HERE/dist/ext/lz-intervals-track.min.js\" type=\"application/javascript\"></script>\n * ```\n *\n * To use with ES6 modules, the plugin must be loaded and registered explicitly before use:\n * ```\n * import LocusZoom from 'locuszoom';\n * import IntervalsTrack from 'locuszoom/esm/ext/lz-intervals-track';\n * LocusZoom.use(IntervalsTrack);\n * ```\n *\n * Then use the layouts made available by this extension. (see demos and documentation for guidance)\n * @module\n */\n\nimport * as d3 from 'd3';\n\n\n// Coordinates (start, end) are cached to facilitate rendering\nconst XCS = Symbol.for('lzXCS');\nconst YCS = Symbol.for('lzYCS');\nconst XCE = Symbol.for('lzXCE');\nconst YCE = Symbol.for('lzYCE');\n\n\nfunction install (LocusZoom) {\n    const BaseApiAdapter = LocusZoom.Adapters.get('BaseApiAdapter');\n    const _Button = LocusZoom.Widgets.get('_Button');\n    const _BaseWidget = LocusZoom.Widgets.get('BaseWidget');\n\n    /**\n     * (**extension**) Retrieve Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)\n     * @public\n     * @alias module:LocusZoom_Adapters~IntervalLZ\n     * @see module:LocusZoom_Adapters~BaseApiAdapter\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     * @param {number} config.params.source The numeric ID for a specific dataset as assigned by the API server\n     */\n    class IntervalLZ extends BaseApiAdapter {\n        getURL(state, chain, fields) {\n            const source = chain.header.bedtracksource || this.params.source;\n            const query = `?filter=id in ${source} and chromosome eq '${state.chr}' and start le ${state.end} and end ge ${state.start}`;\n            return `${this.url}${query}`;\n        }\n    }\n\n    /**\n     * (**extension**) Button to toggle split tracks mode in an intervals track. This button only works as a panel-level toolbar\n     *   and when used with an intervals data layer from this extension.\n     * @alias module:LocusZoom_Widgets~toggle_split_tracks\n     * @see module:LocusZoom_Widgets~BaseWidget\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    class ToggleSplitTracks extends _BaseWidget {\n        /**\n         * @param {string} layout.data_layer_id The ID of the data layer that this button is intended to control.\n         */\n        constructor(layout) {\n            super(...arguments);\n            if (!layout.data_layer_id) {\n                layout.data_layer_id = 'intervals';\n            }\n            if (!this.parent_panel.data_layers[layout.data_layer_id]) {\n                throw new Error('Toggle split tracks widget specifies an invalid data layer ID');\n            }\n        }\n\n        update() {\n            const data_layer = this.parent_panel.data_layers[this.layout.data_layer_id];\n            const html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';\n            if (this.button) {\n                this.button.setHtml(html);\n                this.button.show();\n                this.parent.position();\n                return this;\n            } else {\n                this.button = new _Button(this)\n                    .setColor(this.layout.color)\n                    .setHtml(html)\n                    .setTitle('Toggle whether tracks are split apart or merged together')\n                    .setOnclick(() => {\n                        data_layer.toggleSplitTracks();\n                        // FIXME: the timeout calls to scale and position (below) cause full ~5 additional re-renders\n                        //  If we can remove these it will greatly speed up re-rendering.\n                        // The key problem here is that the height is apparently not known in advance and is determined after re-render.\n                        if (this.scale_timeout) {\n                            clearTimeout(this.scale_timeout);\n                        }\n                        this.scale_timeout = setTimeout(() => {\n                            this.parent_panel.scaleHeightToData();\n                            this.parent_plot.positionPanels();\n                        }, 0);\n                        this.update();\n                    });\n                return this.update();\n            }\n        }\n    }\n\n\n    /**\n     * (**extension**) Convert a value \"\"rr,gg,bb\" (if given) to a css-friendly color string: \"rgb(rr,gg,bb)\".\n     * This is tailored specifically to the color specification format embraced by the BED file standard.\n     * @alias module:LocusZoom_ScaleFunctions~to_rgb\n     * @param {Object} parameters This function has no defined configuration options\n     * @param {String|null} value The value to convert to rgb\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    function to_rgb(parameters, value) {\n        return value ? `rgb(${value})` : null;\n    }\n\n    const default_layout = {\n        start_field: 'start',\n        end_field: 'end',\n        track_label_field: 'state_name', // Used to label items on the y-axis\n        // Used to uniquely identify tracks for coloring. This tends to lead to more stable coloring/sorting\n        //  than using the label field- eg, state_ids allow us to set global colors across the entire dataset,\n        //  not just choose unique colors within a particular narrow region. (where changing region might lead to more\n        //  categories and different colors)\n        track_split_field: 'state_id',\n        track_split_order: 'DESC',\n        track_split_legend_to_y_axis: 2,\n        split_tracks: true,\n        track_height: 15,\n        track_vertical_spacing: 3,\n        bounding_box_padding: 2,\n        always_hide_legend: false,\n        color: '#B8B8B8',\n        fill_opacity: 1,\n        tooltip_positioning: 'vertical',\n    };\n\n    const BaseLayer = LocusZoom.DataLayers.get('BaseDataLayer');\n\n    /**\n     * (**extension**) Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)\n     * Each interval (such as from a BED file) will be rendered as a rectangle. All spans can be rendered on the same\n     *  row, or each (auto-detected) category can be rendered as one row per category.\n     *\n     * This layer is intended to work with a variety of datasets with special requirements. As such, it has a lot\n     *  of configuration options devoted to identifying how to fill in missing information (such as color)\n     *\n     * @alias module:LocusZoom_DataLayers~intervals\n     * @see module:LocusZoom_DataLayers~BaseDataLayer\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    class LzIntervalsTrack extends BaseLayer {\n        /**\n         * @param {string} [layout.start_field='start'] The field that defines interval start position\n         * @param {string} [layout.end_field='end'] The field that defines interval end position\n         * @param {string} [layout.track_label_field='state_name'] Used to label items on the y-axis\n         * @param {string} [layout.track_split_field='state_id'] Used to define categories on the y-axis. It is usually most convenient to use\n         *  the same value for state_field and label_field (eg 1:1 correspondence).\n         * @param {*|'DESC'} [layout.track_split_order='DESC'] When in split tracks mode, should categories be shown in\n         *  the order given, or descending order\n         * @param {number} [layout.track_split_legend_to_y_axis=2]\n         * @param {boolean} [layout.split_tracks=true] Whether to show tracks as merged (one row) or split (many rows)\n         *  on initial render.\n         * @param {number} [layout.track_height=15] The height of each interval rectangle, in px\n         * @param {number} [layout.track_vertical_spacing=3]\n         * @param {number} [layout.bounding_box_padding=2]\n         * @param {boolean} [layout.always_hide_legend=false] Normally the legend is shown in merged mode and hidden\n         *  in split mode. For datasets with a very large number of categories, it may make sense to hide the legend at all times.\n         * @param {string|module:LocusZoom_DataLayers~ScalableParameter[]} [layout.color='#B8B8B8'] The color of each datum rectangle\n         * @param {number|module:LocusZoom_DataLayers~ScalableParameter[]} [layout.fill_opacity=1]\n         * @param {string} [layout.tooltip_positioning='vertical']\n         */\n        constructor(layout) {\n            LocusZoom.Layouts.merge(layout, default_layout);\n            super(...arguments);\n            this._previous_categories = [];\n            this._categories = [];\n        }\n\n        initialize() {\n            super.initialize();\n            this._statusnodes_group = this.svg.group.append('g')\n                .attr('class', 'lz-data-layer-intervals lz-data-layer-intervals-statusnode');\n            this._datanodes_group = this.svg.group.append('g')\n                .attr('class', 'lz-data_layer-intervals');\n        }\n\n        /**\n         * Split data into tracks such that anything with a common grouping field is in the same track\n         * @param data\n         * @return {unknown[]}\n         * @private\n         */\n        _arrangeTrackSplit(data) {\n            const {track_split_field} = this.layout;\n            const result = {};\n            data.forEach((item) => {\n                const item_key = item[track_split_field];\n                if (!Object.prototype.hasOwnProperty.call(result, item_key)) {\n                    result[item_key] = [];\n                }\n                result[item_key].push(item);\n            });\n            return result;\n        }\n\n        /**\n         * Split data into rows using a simple greedy algorithm such that no two items overlap (share same interval)\n         * Assumes that the data are sorted so item1.start always <= item2.start.\n         *\n         * This function can also simply return all data on a single row. This functionality may become configurable\n         *  in the future but for now reflects a lack of clarity in the requirements/spec. The code to split\n         *  overlapping items is present but may not see direct use.\n         */\n        _arrangeTracksLinear(data, allow_overlap = true) {\n            if (allow_overlap) {\n                // If overlap is allowed, then all the data can live on a single row\n                return [data];\n            }\n\n            // ASSUMPTION: Data is given to us already sorted by start position to facilitate grouping.\n            // We do not sort here because JS \"sort\" is not stable- if there are many intervals that overlap, then we\n            //   can get different layouts (number/order of rows) on each call to \"render\".\n            //\n            // At present, we decide how to update the y-axis based on whether current and former number of rows are\n            //  the same. An unstable sort leads to layout thrashing/too many re-renders. FIXME: don't rely on counts\n            const {start_field, end_field} = this.layout;\n\n            const grouped_data = [[]]; // Prevent two items from colliding by rendering them to different rows, like genes\n            data.forEach((item, index) => {\n                for (let i = 0; i < grouped_data.length; i++) {\n                    // Iterate over all rows of the\n                    const row_to_test = grouped_data[i];\n                    const last_item = row_to_test[row_to_test.length - 1];\n                    // Some programs report open intervals, eg 0-1,1-2,2-3; these points are not considered to overlap (hence the test isn't \"<=\")\n                    const has_overlap = last_item && (item[start_field] < last_item[end_field]) && (last_item[start_field] < item[end_field]);\n                    if (!has_overlap) {\n                        // If there is no overlap, add item to current row, and move on to the next item\n                        row_to_test.push(item);\n                        return;\n                    }\n                }\n                // If this item would collide on all existing rows, create a new row\n                grouped_data.push([item]);\n            });\n            return grouped_data;\n        }\n\n        /**\n         * Annotate each item with the track number, and return.\n         * @param {Object[]}data\n         * @private\n         * @return [String[], Object[]] Return the categories and the data array\n         */\n        _assignTracks(data) {\n            // Flatten the grouped data.\n            const {x_scale} = this.parent;\n            const {start_field, end_field, bounding_box_padding, track_height} = this.layout;\n\n            const grouped_data = this.layout.split_tracks ? this._arrangeTrackSplit(data) : this._arrangeTracksLinear(data, true);\n            const categories = Object.keys(grouped_data);\n            if (this.layout.track_split_order === 'DESC') {\n                categories.reverse();\n            }\n\n            categories.forEach((key, row_index) => {\n                const row = grouped_data[key];\n                row.forEach((item) => {\n                    item[XCS] = x_scale(item[start_field]);\n                    item[XCE] = x_scale(item[end_field]);\n                    item[YCS] = row_index * this.getTrackHeight() + bounding_box_padding;\n                    item[YCE] = item[YCS] + track_height;\n                    // Store the row ID, so that clicking on a point can find the right status node (big highlight box)\n                    item.track = row_index;\n                });\n            });\n            // We're mutating elements of the original data array as a side effect: the return value here is\n            //  interchangeable with `this.data` for subsequent usages\n            // TODO: Can replace this with array.flat once polyfill support improves\n            return [categories, Object.values(grouped_data).reduce((acc, val) => acc.concat(val), [])];\n        }\n\n        /**\n         * When we are in \"split tracks mode\", it's convenient to wrap all individual annotations with a shared\n         *  highlight box that wraps everything on that row.\n         *\n         * This is done automatically by the \"setElementStatus\" code, if this function returns a non-null value\n         *\n         * To define shared highlighting on the track split field define the status node id override\n         * to generate an ID common to the track when we're actively splitting data out to separate tracks\n         * @override\n         * @returns {String}\n         */\n        getElementStatusNodeId(element) {\n            if (this.layout.split_tracks) {\n                // Data nodes are bound to data objects, but the \"status_nodes\" selection is bound to numeric row IDs\n                const track = typeof element === 'object' ? element.track : element;\n                const base = `${this.getBaseId()}-statusnode-${track}`;\n                return base.replace(/[^\\w]/g, '_');\n            }\n            // In merged tracks mode, there is no separate status node\n            return null;\n        }\n\n        // Helper function to sum layout values to derive total height for a single interval track\n        getTrackHeight() {\n            return this.layout.track_height\n                + this.layout.track_vertical_spacing\n                + (2 * this.layout.bounding_box_padding);\n        }\n\n        // Modify the layout as necessary to ensure that appropriate color, label, and legend options are available\n        // Even when not displayed, the legend is used to generate the y-axis ticks\n        _applyLayoutOptions() {\n            const self = this;\n            const base_layout = this._base_layout;\n            const render_layout = this.layout;\n            const base_color_scale = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            const color_scale = render_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            if (!base_color_scale) {\n                // This can be a placeholder (empty categories & values), but it needs to be there\n                throw new Error('Interval tracks must define a `categorical_bin` color scale');\n            }\n\n            const has_colors = base_color_scale.parameters.categories.length && base_color_scale.parameters.values.length;\n            const has_legend = base_layout.legend && base_layout.legend.length;\n\n            if (!!has_colors ^ !!has_legend) {\n                // Don't allow color OR legend to be set manually. It must be both, or neither.\n                throw new Error('To use a manually specified color scheme, both color and legend options must be set.');\n            }\n\n            // Harvest any information about an explicit color field that should be considered when generating colors\n            const rgb_option = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'to_rgb';\n            });\n            const rgb_field = rgb_option && rgb_option.field;\n\n            // Auto-generate legend based on data\n            const known_categories = this._generateCategoriesFromData(this.data, rgb_field); // [id, label, itemRgb] items\n\n            if (!has_colors && !has_legend) {\n                // If no color scheme pre-defined, then make a color scheme that is appropriate and apply to the plot\n                // The legend must match the color scheme. If we generate one, then we must generate both.\n\n                const colors = this._makeColorScheme(known_categories);\n                color_scale.parameters.categories = known_categories.map(function (item) {\n                    return item[0];\n                });\n                color_scale.parameters.values = colors;\n\n                this.layout.legend = known_categories.map(function (pair, index) {\n                    const id = pair[0];\n                    const label = pair[1];\n                    const item_color = color_scale.parameters.values[index];\n                    const item = { shape: 'rect', width: 9, label: label, color: item_color };\n                    item[self.layout.track_split_field] = id;\n                    return item;\n                });\n            }\n        }\n\n        // Implement the main render function\n        render() {\n            //// Autogenerate layout options if not provided\n            this._applyLayoutOptions();\n\n            // Determine the appropriate layout for tracks. Store the previous categories (y axis ticks) to decide\n            //   whether the axis needs to be re-rendered.\n            this._previous_categories = this._categories;\n            const [categories, assigned_data] = this._assignTracks(this.data);\n            this._categories = categories;\n            // Update the legend axis if the number of ticks changed\n            const labels_changed = !categories.every( (item, index) => item === this._previous_categories[index]);\n            if (labels_changed) {\n                this.updateSplitTrackAxis(categories);\n                return;\n            }\n\n            // Apply filters to only render a specified set of points. Hidden fields will still be given space to render, but not shown.\n            const track_data = this._applyFilters(assigned_data);\n\n            // Clear before every render so that, eg, highlighting doesn't persist if we load a region with different\n            //  categories (row 2 might be a different category and it's confusing if the row stays highlighted but changes meaning)\n            // Highlighting will automatically get added back if it actually makes sense, courtesy of setElementStatus,\n            //  if a selected item is still in view after the new region loads.\n            this._statusnodes_group.selectAll('rect')\n                .remove();\n\n            // Reselect in order to add new data\n            const status_nodes = this._statusnodes_group.selectAll('rect')\n                .data(d3.range(categories.length));\n\n            if (this.layout.split_tracks) {\n                // Status nodes: a big highlight box around all items of the same type. Used in split tracks mode,\n                //  because everything on the same row is the same category and a group makes sense\n                // There are no status nodes in merged mode, because the same row contains many kinds of things\n\n                // Status nodes are 1 per row, so \"data\" can just be a dummy list of possible row IDs\n                // Each status node is a box that runs the length of the panel and receives a special \"colored box\" css\n                //  style when selected\n                const height = this.getTrackHeight();\n                status_nodes.enter()\n                    .append('rect')\n                    .attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared')\n                    .attr('rx', this.layout.bounding_box_padding)\n                    .attr('ry', this.layout.bounding_box_padding)\n                    .merge(status_nodes)\n                    .attr('id', (d) => this.getElementStatusNodeId(d))\n                    .attr('x', 0)\n                    .attr('y', (d) => (d * height))\n                    .attr('width', this.parent.layout.cliparea.width)\n                    .attr('height', height - this.layout.track_vertical_spacing);\n            }\n            status_nodes.exit()\n                .remove();\n\n            // Draw rectangles for the data (intervals)\n            const data_nodes = this._datanodes_group.selectAll('rect')\n                .data(track_data, (d) => d[this.layout.id_field]);\n\n            data_nodes.enter()\n                .append('rect')\n                .merge(data_nodes)\n                .attr('id', (d) => this.getElementId(d))\n                .attr('x', (d) => d[XCS])\n                .attr('y', (d) => d[YCS])\n                .attr('width', (d) => d[XCE] - d[XCS])\n                .attr('height', this.layout.track_height)\n                .attr('fill', (d, i) => this.resolveScalableParameter(this.layout.color, d, i))\n                .attr('fill-opacity', (d, i) => this.resolveScalableParameter(this.layout.fill_opacity, d, i));\n\n            data_nodes.exit()\n                .remove();\n\n            this._datanodes_group\n                .call(this.applyBehaviors.bind(this));\n\n            // The intervals track allows legends to be dynamically generated, in which case space can only be\n            //  allocated after the panel has been rendered.\n            if (this.parent && this.parent.legend) {\n                this.parent.legend.render();\n            }\n        }\n\n        _getTooltipPosition(tooltip) {\n            return {\n                x_min: tooltip.data[XCS],\n                x_max: tooltip.data[XCE],\n                y_min: tooltip.data[YCS],\n                y_max: tooltip.data[YCE],\n            };\n        }\n\n        // Redraw split track axis or hide it, and show/hide the legend, as determined\n        // by current layout parameters and data\n        updateSplitTrackAxis(categories) {\n            const legend_axis = this.layout.track_split_legend_to_y_axis ? `y${this.layout.track_split_legend_to_y_axis}` : false;\n            if (this.layout.split_tracks) {\n                const tracks = +categories.length || 0;\n                const track_height = +this.layout.track_height || 0;\n                const track_spacing = 2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);\n                const target_height = (tracks * track_height) + ((tracks - 1) * track_spacing);\n                this.parent.scaleHeightToData(target_height);\n                if (legend_axis && this.parent.legend) {\n                    this.parent.legend.hide();\n                    this.parent.layout.axes[legend_axis] = {\n                        render: true,\n                        ticks: [],\n                        range: {\n                            start: (target_height - (this.layout.track_height / 2)),\n                            end: (this.layout.track_height / 2),\n                        },\n                    };\n                    // There is a very tight coupling between the display directives: each legend item must identify a key\n                    //  field for unique tracks. (Typically this is `state_id`, the same key field used to assign unique colors)\n                    // The list of unique keys corresponds to the order along the y-axis\n                    this.layout.legend.forEach((element) => {\n                        const key = element[this.layout.track_split_field];\n                        let track = categories.findIndex((item) => item === key);\n                        if (track !== -1) {\n                            if (this.layout.track_split_order === 'DESC') {\n                                track = Math.abs(track - tracks - 1);\n                            }\n                            this.parent.layout.axes[legend_axis].ticks.push({\n                                y: track - 1,\n                                text: element.label,\n                            });\n                        }\n                    });\n                    this.layout.y_axis = {\n                        axis: this.layout.track_split_legend_to_y_axis,\n                        floor: 1,\n                        ceiling: tracks,\n                    };\n                }\n                // This will trigger a re-render\n                this.parent_plot.positionPanels();\n            } else {\n                if (legend_axis && this.parent.legend) {\n                    if (!this.layout.always_hide_legend) {\n                        this.parent.legend.show();\n                    }\n                    this.parent.layout.axes[legend_axis] = { render: false };\n                    this.parent.render();\n                }\n            }\n            return this;\n        }\n\n        // Method to not only toggle the split tracks boolean but also update\n        // necessary display values to animate a complete merge/split\n        toggleSplitTracks() {\n            this.layout.split_tracks = !this.layout.split_tracks;\n            if (this.parent.legend && !this.layout.always_hide_legend) {\n                this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);\n            }\n            this.render();\n            return this;\n        }\n\n        // Choose an appropriate color scheme based on the number of items in the track, and whether or not we are\n        //  using explicitly provided itemRgb information\n        _makeColorScheme(category_info) {\n            // If at least one element has an explicit itemRgb, assume the entire dataset has colors\n            const has_explicit_colors = category_info.find((item) => item[2]);\n            if (has_explicit_colors) {\n                return category_info.map((item) => item[2]);\n            }\n\n            // Use a set of color schemes for common 15, 18, or 25 state models, as specified from:\n            //  https://egg2.wustl.edu/roadmap/web_portal/chr_state_learning.html\n            // These are actually reversed so that dim colors come first, on the premise that usually these are the\n            //  most common states\n            const n_categories = category_info.length;\n            if (n_categories <= 15) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(233,150,122)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(50,205,50)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else if (n_categories <= 18) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else {\n                // If there are more than 25 categories, the interval layer will fall back to the 'null value' option\n                return ['rgb(212,212,212)', 'rgb(128,128,128)', 'rgb(112,48,160)', 'rgb(230,184,183)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,102)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,150,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            }\n        }\n\n        /**\n         * Find all of the unique tracks (a combination of name and ID information)\n         * @param {Object} data\n         * @param {String} [rgb_field] A field that contains an RGB value. Aimed at BED files with an itemRgb column\n         * @private\n         * @returns {Array} All [unique_id, label, color] pairs in data. The unique_id is the thing used to define groupings\n         *  most unambiguously.\n         */\n        _generateCategoriesFromData(data, rgb_field) {\n            const self = this;\n            // Use the hard-coded legend if available (ignoring any mods on re-render)\n            const legend = this._base_layout.legend;\n            if (legend && legend.length) {\n                return legend.map((item) => [item[this.layout.track_split_field], item.label, item.color]);\n            }\n\n            // Generate options from data, if no preset legend exists\n            const unique_ids = {}; // make categories unique\n            const categories = [];\n\n            data.forEach((item) => {\n                const id = item[self.layout.track_split_field];\n                if (!Object.prototype.hasOwnProperty.call(unique_ids, id)) {\n                    unique_ids[id] = null;\n                    // If rgbfield is null, then the last entry is undefined/null as well\n                    categories.push([id, item[this.layout.track_label_field], item[rgb_field]]);\n                }\n            });\n            return categories;\n        }\n    }\n\n    /**\n     * (**extension**) A basic tooltip with information to be shown over an intervals datum\n     * @alias module:LocusZoom_Layouts~standard_intervals\n     * @type tooltip\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_tooltip_layout = {\n        namespace: { 'intervals': 'intervals' },\n        closable: false,\n        show: { or: ['highlighted', 'selected'] },\n        hide: { and: ['unhighlighted', 'unselected'] },\n        html: '{{{{namespace[intervals]}}state_name|htmlescape}}<br>{{{{namespace[intervals]}}start|htmlescape}}-{{{{namespace[intervals]}}end|htmlescape}}',\n    };\n\n    /**\n     * (**extension**) A data layer with some preconfigured options for intervals display. This example was designed for chromHMM output,\n     *   in which various states are assigned numeric state IDs and (<= as many) text state names\n     * @alias module:LocusZoom_Layouts~intervals_layer\n     * @type data_layer\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_layer_layout =  {\n        namespace: { 'intervals': 'intervals' },\n        id: 'intervals',\n        type: 'intervals',\n        fields: ['{{namespace[intervals]}}start', '{{namespace[intervals]}}end', '{{namespace[intervals]}}state_id', '{{namespace[intervals]}}state_name', '{{namespace[intervals]}}itemRgb'],\n        id_field: '{{namespace[intervals]}}start',  // FIXME: This is not a good D3 \"are these datums redundant\" ID for datasets with multiple intervals heavily overlapping\n        start_field: '{{namespace[intervals]}}start',\n        end_field: '{{namespace[intervals]}}end',\n        track_split_field: '{{namespace[intervals]}}state_name',\n        track_label_field: '{{namespace[intervals]}}state_name',\n        split_tracks: false,\n        always_hide_legend: true,\n        color: [\n            {\n                // If present, an explicit color field will override any other option (and be used to auto-generate legend)\n                field: '{{namespace[intervals]}}itemRgb',\n                scale_function: 'to_rgb',\n            },\n            {\n                // TODO: Consider changing this to stable_choice in the future, for more stable coloring\n                field: '{{namespace[intervals]}}state_name',\n                scale_function: 'categorical_bin',\n                parameters: {\n                    // Placeholder. Empty categories and values will automatically be filled in when new data loads.\n                    categories: [],\n                    values: [],\n                    null_value: '#B8B8B8',\n                },\n            },\n        ],\n        legend: [], // Placeholder; auto-filled when data loads.\n        behaviors: {\n            onmouseover: [\n                { action: 'set', status: 'highlighted' },\n            ],\n            onmouseout: [\n                { action: 'unset', status: 'highlighted' },\n            ],\n            onclick: [\n                { action: 'toggle', status: 'selected', exclusive: true },\n            ],\n            onshiftclick: [\n                { action: 'toggle', status: 'selected' },\n            ],\n        },\n        tooltip: intervals_tooltip_layout,\n    };\n\n    /**\n     * (**extension**) A panel containing an intervals data layer, eg for BED tracks\n     * @alias module:LocusZoom_Layouts~intervals\n     * @type panel\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_panel_layout = {\n        id: 'intervals',\n        min_height: 50,\n        height: 50,\n        margin: { top: 25, right: 150, bottom: 5, left: 50 },\n        toolbar: (function () {\n            const l = LocusZoom.Layouts.get('toolbar', 'standard_panel', { unnamespaced: true });\n            l.widgets.push({\n                type: 'toggle_split_tracks',\n                data_layer_id: 'intervals',\n                position: 'right',\n            });\n            return l;\n        })(),\n        axes: {},\n        interaction: {\n            drag_background_to_pan: true,\n            scroll_to_zoom: true,\n            x_linked: true,\n        },\n        legend: {\n            hidden: true,\n            orientation: 'horizontal',\n            origin: { x: 50, y: 0 },\n            pad_from_bottom: 5,\n        },\n        data_layers: [intervals_layer_layout],\n    };\n\n    /**\n     * (**extension**) A plot layout that shows association summary statistics, genes, and interval data. This example assumes\n     *  chromHMM data. (see panel layout)\n     * @alias module:LocusZoom_Layouts~interval_association\n     * @type tooltip\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_plot_layout = {\n        state: {},\n        width: 800,\n        responsive_resize: true,\n        min_region_scale: 20000,\n        max_region_scale: 1000000,\n        toolbar: LocusZoom.Layouts.get('toolbar', 'standard_association', { unnamespaced: true }),\n        panels: [\n            LocusZoom.Layouts.get('panel', 'association'),\n            LocusZoom.Layouts.merge({ unnamespaced: true, min_height: 120, height: 120 }, intervals_panel_layout),\n            LocusZoom.Layouts.get('panel', 'genes'),\n        ],\n    };\n\n    LocusZoom.Adapters.add('IntervalLZ', IntervalLZ);\n    LocusZoom.DataLayers.add('intervals', LzIntervalsTrack);\n\n    LocusZoom.Layouts.add('tooltip', 'standard_intervals', intervals_tooltip_layout);\n    LocusZoom.Layouts.add('data_layer', 'intervals', intervals_layer_layout);\n    LocusZoom.Layouts.add('panel', 'intervals', intervals_panel_layout);\n    LocusZoom.Layouts.add('plot', 'interval_association', intervals_plot_layout);\n\n    LocusZoom.ScaleFunctions.add('to_rgb', to_rgb);\n\n    LocusZoom.Widgets.add('toggle_split_tracks', ToggleSplitTracks);\n}\n\nif (typeof LocusZoom !== 'undefined') {\n    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()\n    // eslint-disable-next-line no-undef\n    LocusZoom.use(install);\n}\n\n\nexport default install;\n"],"sourceRoot":""}